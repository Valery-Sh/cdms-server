<!--
To change this template, choose Tools | Templates
and open the template in the editor.
-->
<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <h3 style="color: blue">Содержание</h3>
        <ul>
            <li><a href="#protocol">Коммуникационный протокол</a></li>
            <li><a href="#orm">Выбор ORM и Persistance API</a></li>
            <li><a href="#auth">Аутентификация и Авторизация</a></li>
            <li><a href="#valid">Валидация</a></li>            
            <li><a href="#valid">Асинхронные запросы к серверу</a></li>            
            <li><a href="#paging">Paging. Ограничение объема передаваемых данных</a></li>
            
        </ul>
        
        <h4 id="protocol">Коммуникационный протокол</h4>
        
        Для коммуникации между клиентом и сервером избран HTTP протокол. <br/>
        <h5>Причина:</h5>            
        <ul>
            <li>Широкое распростанение Интернет;</li>
            <li>Доступность развитых средств разработки.</li>
        </ul>
        <code>Spring Framework</code> предлагает "из коробри" несколько API
        для работы через Http, например:
        <ul>
            <li>Web Services ( SOAP и т.д);</li>
            <li>HttpInvoker</li>
            <li>Hessian Binary Remote</li>
            <li>Burlap</li>
        </ul>
        Наиболее предпочтительным мог бы стать <code>HttpInvoker</code>, если 
        бы мы хотели использовать <code>Spring</code> как на клиенте, так и 
        на сервере. Но, поскольку клиент - это <code>NetBeans RCP</code>
        приложение, то использование <code>Spring</code> будет чересчур 
        избыточным. Поэтому, для разработки выбран <code>Hessian</code>. 
        Чтобы избежать тесной зависимости от <code>Hessian</code>, необходимо 
        сервисы, использующие удаленные вызовы, реализовать
        как lookup-сервисы, с тем, чтобы можно было легко подключать модули, 
        реализующии remoting по другим протоколам.
        
         <h5>Недостатки Hessian</h5> 
         
         Содержит недокументированые ошибки:
         <ul>
             <li>Неправильная сериализация/десериализация типов <code>BigDecimal,BigInteger</code></li>
             <li>Типы Long (а, возможно, и другие) всегда null при использовании как тип параметров вызова методов. </li>
         </ul>
         <h5>Замена Hessian на другой протокол в клиентском приложении</h5>  
         Клиентское приложение содержит несколько независимых друг от друга интерфейсов,
         которые используются для удаленного доступа к данным. Например, для доступа
         к данным используются интерфейсы <code>AuthService,CustomerService,
         InvoiceService, StatisticsService,ProductItemService</code>. 
         Объекты реальных классов, реализующих эти интерфейсы,
         запрашиваются через <code>Global lookup</code>. Например, для доступа к
         <code>CustomerService</code>  используется вызов:
         <pre><code>
                CustomerServiceProvider.getDefault().getInstance();                     
         </code>
         </pre>
         Если в системе не зарегистрировано другого провайдера, то, по умолчанию
         выбирается <code>HessianService</code>. <br/>
         Таким образом, чтобы заменить <code>Hessian</code>, например, 
         на <code>Burlap</code>, необходимо
         разработать класс, наследующий от абстрактного класса 
         <code>CustomerServiceProvider</code>, и определить его как 
         сервису-провайдер, применив аннотацию
         <code>@ServiceProvider</code>. NetBeans Module, включающий класс 
         добавить к приложению.  Необходимо отметить, что новый 
         сервис-провайдер повлияет только на <code>CustomerService</code>. 
         Для других сервисов необходимо проделать создаие отдельных
         классов-провайдеров. Это позволяет для различных по 
         функциональности классов выбирать разные  протоколы доступа. 
         Например, в компании может быть отдельный сервер аутентификации,
         к которому доступ осуществляется через <code>SOAP Web Service</code>.
         
        <h4 id="orm">Выбор ORM и Persistance API</h4>
        
        Серверное приложение использует <code>Hibernate</code> как 
        <code>Persistance Framework</code>.
        Все классы, реализующие сервисы <code>DAO</code>, размещены в пакете 
        <code>org.cdms.domain.dao.hibernate</code>
        Если потребуется заменить framework, то следует разработать пакет классов,
        реализующих <code>DAO</code> сервисы из пакета <code>org.cdms.domain.dao</code>, например,
        <code>org.cdms.domain.dao.jpa</code>, поместить пакет в classpath
        приложения и конфигурировать в контексте <code>Spring MVC</code>.
        
        <h5>Примечание.</h5>            
        Для промышленной эксплуатации, по моему мнению, на сегодняшний момент
        можно попробовать <code>Spring Data Framework</code>.
        
        <h4 id="auth">Аутентификация и Авторизация</h4>         
        
        <code>Hessian API</code> позволяет при вызове метода из удаленного 
        клиента передавать имя пользователя и пароль для 
        <code>Basic Authetication</code> процедуры.
        Поэтому, сервер  конфигурирован для использования 
        <code>Basic Authentication</code>. В промышленно-пригодном
        приложении необходимо изменить протокол аутентификации. Как правило, 
        такая замена требует знания политики предприятия относительно безопасности и
        методов ее реализации. Наиболее подхоящим, наверное, было бы использование
        <code>https</code>, хотя бы для проведения аутентификации. 
        Для изменения в приложении  протокола аутентификации потребуется 
        создание классов, расширяющих  базовый пакет <code>Hessian</code> как 
        на клиенте, так и на сервере, чтобы получить доступ к заголовкам 
        <code>Http</code>.
        
        <h4 id="valid">Валидация</h4>         
        
        В тестовом приложении <code>CDMS</code> нет  сложных конструкций, связанных
        с проверкой данных на валидность. Поэтому, все проверки проводятся 
        на сервере с использованием <code>javax.validation API</code>. Однако,
        классы, ответственные за валидацию и обработку ошибок разработаны
        отдельно и могут быть расширены как для серверного приложения, так и для
        клиентского. Поскольку клиентское приложения использует
        Java Bean Binding, то на клиенте можно воспользоваться предосталяемыми
        этим framework простыми, но эффективными средствами валидации.

        <h4 id="bkg">Асинхронные запросы к серверу</h4>         
        
        Все запросы к серверу, за исключением запроса на аутентификацию, 
        выполняются клиентом асинхронно, и, тем самым, не блокируют работу
        пользователя. Последнии версии NetBeans включают поддержку <i>async
        actions</i>. Достаточно создать Action класс и аннотировать его как
        asynchronous. Однако, нет никакой возможности изменить курсор мыши. А
        при исполнения async так и sync action появляется курсор в состоянии <i>busy</i>
        вместо <i>background</i>. Это крайне неудобно для пользователя ( если только
        не поменять настройки OS). По этой и только по этой причине асинхронное
        выполнение запрсов реализовано с использованием пакета 
        <code>org.openide.util</code>  из NetBeans API. 
        
        <h4 id="optim">Параллельное редактирование записи</h4>         
        
        Все entity объекты приложения включают поле с аннотацией 
        <code>@Version</code>. Это позволяет 
        <code>Persistance API</code> проверить операции одновременного обновления/удаления
        одной и той же записи. При возникновении такой ситуации 
        <code>Hibernate</code> выбрасывает исключение типа
        <code>HibernateOptimisticLockingFailureException</code>. Это исключение 
        как и другие исключения транслируются приложением во внутреннее 
        представление и передается клиенту. Клиент оповещает о попытке изменить уже
        измененную/удаленную запись пользователя высвечивая сообщение и предлагая
        повторить попытку изменения.
        
        <h4 id="paging">Ограничение объема передаваемых данных</h4>         

        Сервер не возвращает сразу все результаты запроса к базе данных.
        Количество возвращемых записей определяется значением <i>размера страницы</i>.
        Это значение задается пользователем через IDE компонент и может им меняться.
        При выполнении запроса к серверу ему передается номер запращиваемой страницы и размер страницы.
        
    </body>
</html>
